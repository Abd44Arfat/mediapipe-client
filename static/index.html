<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Synthima</title>
  <link rel="icon" type="image/png" href="static/logo1.png">
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
      background-color: #202F36;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      object-fit: cover;
    }

    #button-container {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
      background-color: #2c3e50;
      border-radius: 30px;
      padding: 8px;
      display: flex;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    #button-container button {
      background-color: transparent;
      border: none;
      color: #E7EFFD;
      padding: 12px 16px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 48px;
      height: 48px;
    }

    #button-container button:hover {
      background-color: rgba(255, 255, 255, 0.1);
      transform: scale(1.05);
    }

    #button-container button:active {
      transform: scale(0.95);
    }

    /* SVG icons */
    .icon {
      width: 20px;
      height: 20px;
      stroke: currentColor;
      stroke-width: 2;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    #prediction {
      position: absolute;
      bottom: 110px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 16px 28px;
      font-size: 24px;
      font-weight: 600;
      color: #156DE6;
      background-color: #E7EFFD;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(21, 109, 230, 0.2);
      max-width: 90%;
      text-align: center;
      border: 2px solid rgba(21, 109, 230, 0.1);
    }

    /* Hide back button on smaller screens, keep clear button */
    @media (max-width: 480px) {
      #back-button {
        display: none;
      }

      #prediction {
        font-size: 20px;
        padding: 12px 20px;
        bottom: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="input_video" autoplay muted playsinline></video>
    <canvas id="output_canvas"></canvas>
  </div>
  
  <div id="button-container">
    <button id="back-button" onclick="history.back()" title="Go Back">
      <svg class="icon" viewBox="0 0 24 24">
        <path d="m12 19-7-7 7-7"/>
        <path d="M19 12H5"/>
      </svg>
    </button>
    <button id="clear-button" title="Clear Prediction">
      <svg class="icon" viewBox="0 0 24 24">
        <path d="M3 6h18"/>
        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/>
        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
        <line x1="10" x2="10" y1="11" y2="17"/>
        <line x1="14" x2="14" y1="11" y2="17"/>
      </svg>
    </button>
  </div>
  
  <div id="prediction">Waiting for prediction...</div>

  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const predictionEl = document.getElementById('prediction');
    const clearButton = document.getElementById('clear-button');

    const protocol = location.protocol === "https:" ? "wss" : "ws";
    const ws = new WebSocket(`${protocol}://${location.host}/ws/predict`);

    ws.onopen = () => console.log('‚úÖ WebSocket connected');
    ws.onerror = e => console.error('‚ùå WebSocket error:', e);

    ws.onmessage = e => {
      const data = JSON.parse(e.data);
      console.log("üì• Received:", data);

      if (data.confidence !== undefined) {
        console.log("üß† Confidence:", data.confidence);
      }

      if (data.confidence && data.confidence < 0.8) {
        console.log("‚ö†Ô∏è Confidence too low, skipping...");
        return;
      }

      if (data.readable_sentence) {
        console.log("üìù Readable sentence:", data.readable_sentence);
        predictionEl.textContent = "Sentence: " + data.readable_sentence;
      } else if (data.sentence) {
        console.log("üß† Sentence:", data.sentence);
        predictionEl.textContent = "Sentence: " + data.sentence.join(' ');
      }
    };

    clearButton.addEventListener('click', () => {
      predictionEl.textContent = 'Waiting for prediction...';
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'clear' }));
        console.log("üì§ Sent clear action to server");
      }
    });

    function onResults(results) {
      canvasElement.width = results.image.width;
      canvasElement.height = results.image.height;
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiHandLandmarks) {
        for (const landmarks of results.multiHandLandmarks) {
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#58CC02', lineWidth: 2});
          drawLandmarks(canvasCtx, landmarks, {color: '#156DE6', radius: 3});
        }
      }

      const keypoints = [];
      const numHands = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
      console.log("üñêÔ∏è Detected hands:", numHands);

      for (let i = 0; i < 2; i++) {
        if (i < numHands) {
          results.multiHandLandmarks[i].forEach(landmark => {
            keypoints.push(landmark.x);
            keypoints.push(landmark.y);
            keypoints.push(landmark.z);
          });
        } else {
          keypoints.push(...new Array(21 * 3).fill(0));
        }
      }

      console.log("üì¶ Keypoints length:", keypoints.length);
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ keypoints }));
        console.log("üì§ Sent keypoints to server");
      }

      canvasCtx.restore();
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({image: videoElement});
      },
    });

    camera.start();
  </script>
</body>
</html>